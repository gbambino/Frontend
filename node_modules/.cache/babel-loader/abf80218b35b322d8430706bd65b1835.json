{"ast":null,"code":"import _regeneratorRuntime from\"/home/kodachi/Desktop/Frontend1/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/kodachi/Desktop/Frontend1/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/home/kodachi/Desktop/Frontend1/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useRef,useState}from'react';import{BSC_BLOCK_TIME}from'config';import{simpleRpcProvider}from'utils/providers';/**\n * Returns a countdown in seconds of a given block\n */var useBlockCountdown=function useBlockCountdown(blockNumber){var timer=useRef(null);var _useState=useState(0),_useState2=_slicedToArray(_useState,2),secondsRemaining=_useState2[0],setSecondsRemaining=_useState2[1];useEffect(function(){var startCountdown=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var currentBlock;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return simpleRpcProvider.getBlockNumber();case 2:currentBlock=_context.sent;if(blockNumber>currentBlock){setSecondsRemaining((blockNumber-currentBlock)*BSC_BLOCK_TIME);// Clear previous interval\nif(timer.current){clearInterval(timer.current);}timer.current=setInterval(function(){setSecondsRemaining(function(prevSecondsRemaining){if(prevSecondsRemaining===1){clearInterval(timer.current);}return prevSecondsRemaining-1;});},1000);}case 4:case\"end\":return _context.stop();}}},_callee);}));return function startCountdown(){return _ref.apply(this,arguments);};}();startCountdown();return function(){clearInterval(timer.current);};},[setSecondsRemaining,blockNumber,timer]);return secondsRemaining;};export default useBlockCountdown;","map":{"version":3,"sources":["/home/kodachi/Desktop/Frontend1/Frontend1/src/hooks/useGetBlockCountdown.ts"],"names":["useEffect","useRef","useState","BSC_BLOCK_TIME","simpleRpcProvider","useBlockCountdown","blockNumber","timer","secondsRemaining","setSecondsRemaining","startCountdown","getBlockNumber","currentBlock","current","clearInterval","setInterval","prevSecondsRemaining"],"mappings":"6dAAA,OAASA,SAAT,CAAoBC,MAApB,CAA4BC,QAA5B,KAA4C,OAA5C,CACA,OAASC,cAAT,KAA+B,QAA/B,CACA,OAASC,iBAAT,KAAkC,iBAAlC,CAEA;AACA;AACA,GACA,GAAMC,CAAAA,iBAAiB,CAAG,QAApBA,CAAAA,iBAAoB,CAACC,WAAD,CAAyB,CACjD,GAAMC,CAAAA,KAAK,CAAGN,MAAM,CAAgC,IAAhC,CAApB,CACA,cAAgDC,QAAQ,CAAC,CAAD,CAAxD,wCAAOM,gBAAP,eAAyBC,mBAAzB,eAEAT,SAAS,CAAC,UAAM,CACd,GAAMU,CAAAA,cAAc,0FAAG,0KACMN,CAAAA,iBAAiB,CAACO,cAAlB,EADN,QACfC,YADe,eAGrB,GAAIN,WAAW,CAAGM,YAAlB,CAAgC,CAC9BH,mBAAmB,CAAC,CAACH,WAAW,CAAGM,YAAf,EAA+BT,cAAhC,CAAnB,CAEA;AACA,GAAII,KAAK,CAACM,OAAV,CAAmB,CACjBC,aAAa,CAACP,KAAK,CAACM,OAAP,CAAb,CACD,CAEDN,KAAK,CAACM,OAAN,CAAgBE,WAAW,CAAC,UAAM,CAChCN,mBAAmB,CAAC,SAACO,oBAAD,CAA0B,CAC5C,GAAIA,oBAAoB,GAAK,CAA7B,CAAgC,CAC9BF,aAAa,CAACP,KAAK,CAACM,OAAP,CAAb,CACD,CAED,MAAOG,CAAAA,oBAAoB,CAAG,CAA9B,CACD,CANkB,CAAnB,CAOD,CAR0B,CAQxB,IARwB,CAA3B,CASD,CApBoB,sDAAH,kBAAdN,CAAAA,cAAc,0CAApB,CAuBAA,cAAc,GAEd,MAAO,WAAM,CACXI,aAAa,CAACP,KAAK,CAACM,OAAP,CAAb,CACD,CAFD,CAGD,CA7BQ,CA6BN,CAACJ,mBAAD,CAAsBH,WAAtB,CAAmCC,KAAnC,CA7BM,CAAT,CA+BA,MAAOC,CAAAA,gBAAP,CACD,CApCD,CAsCA,cAAeH,CAAAA,iBAAf","sourcesContent":["import { useEffect, useRef, useState } from 'react'\nimport { BSC_BLOCK_TIME } from 'config'\nimport { simpleRpcProvider } from 'utils/providers'\n\n/**\n * Returns a countdown in seconds of a given block\n */\nconst useBlockCountdown = (blockNumber: number) => {\n  const timer = useRef<ReturnType<typeof setTimeout>>(null)\n  const [secondsRemaining, setSecondsRemaining] = useState(0)\n\n  useEffect(() => {\n    const startCountdown = async () => {\n      const currentBlock = await simpleRpcProvider.getBlockNumber()\n\n      if (blockNumber > currentBlock) {\n        setSecondsRemaining((blockNumber - currentBlock) * BSC_BLOCK_TIME)\n\n        // Clear previous interval\n        if (timer.current) {\n          clearInterval(timer.current)\n        }\n\n        timer.current = setInterval(() => {\n          setSecondsRemaining((prevSecondsRemaining) => {\n            if (prevSecondsRemaining === 1) {\n              clearInterval(timer.current)\n            }\n\n            return prevSecondsRemaining - 1\n          })\n        }, 1000)\n      }\n    }\n\n    startCountdown()\n\n    return () => {\n      clearInterval(timer.current)\n    }\n  }, [setSecondsRemaining, blockNumber, timer])\n\n  return secondsRemaining\n}\n\nexport default useBlockCountdown\n"]},"metadata":{},"sourceType":"module"}