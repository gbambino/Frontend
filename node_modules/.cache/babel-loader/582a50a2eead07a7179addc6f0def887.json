{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { LotteryStatus } from 'config/constants/types';\nimport { multicallv2 } from 'utils/multicall';\nimport lotteryV2Abi from 'config/abi/lotteryV2.json';\nimport { getLotteryV2Address } from 'utils/addressHelpers';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { getViewUserTicketInfoCalls, mergeViewUserTicketInfoMulticallResponse, processRawTicketsResponse } from './helpers';\nconst lotteryAddress = getLotteryV2Address();\n\nconst fetchCakeRewardsForTickets = async winningTickets => {\n  const calls = winningTickets.map(winningTicket => {\n    const {\n      roundId,\n      id,\n      rewardBracket\n    } = winningTicket;\n    return {\n      name: 'viewRewardsForTicketId',\n      address: lotteryAddress,\n      params: [roundId, id, rewardBracket]\n    };\n  });\n  const cakeRewards = await multicallv2(lotteryV2Abi, calls);\n  const cakeTotal = cakeRewards.reduce((accum, cakeReward) => {\n    return accum.plus(new BigNumber(cakeReward[0].toString()));\n  }, BIG_ZERO);\n  const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\n    return { ...winningTicket,\n      cakeReward: cakeRewards[index]\n    };\n  });\n  return {\n    ticketsWithUnclaimedRewards,\n    cakeTotal\n  };\n};\n\nconst getRewardBracketByNumber = (ticketNumber, finalNumber) => {\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n  // i.e. '1123456' should be evaluated as '6543211'\n  const ticketNumAsArray = ticketNumber.split('').reverse();\n  const winningNumsAsArray = finalNumber.split('').reverse();\n  const matchingNumbers = []; // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\n\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\n      break;\n    }\n\n    matchingNumbers.push(ticketNumAsArray[index]);\n  } // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\n\n\n  const rewardBracket = matchingNumbers.length - 1;\n  return rewardBracket;\n};\n\nexport const getWinningTickets = async roundDataAndUserTickets => {\n  const {\n    roundId,\n    userTickets,\n    finalNumber\n  } = roundDataAndUserTickets;\n  const ticketsWithRewardBrackets = userTickets.map(ticket => {\n    return {\n      roundId,\n      id: ticket.id,\n      number: ticket.number,\n      status: ticket.status,\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber)\n    };\n  }); // A rewardBracket of -1 means no matches. 0 and above means there has been a match\n\n  const allWinningTickets = ticketsWithRewardBrackets.filter(ticket => {\n    return ticket.rewardBracket >= 0;\n  }); // If ticket.status is true, the ticket has already been claimed\n\n  const unclaimedWinningTickets = allWinningTickets.filter(ticket => {\n    return !ticket.status;\n  });\n\n  if (unclaimedWinningTickets.length > 0) {\n    const {\n      ticketsWithUnclaimedRewards,\n      cakeTotal\n    } = await fetchCakeRewardsForTickets(unclaimedWinningTickets);\n    return {\n      ticketsWithUnclaimedRewards,\n      allWinningTickets,\n      cakeTotal,\n      roundId\n    };\n  }\n\n  if (allWinningTickets.length > 0) {\n    return {\n      ticketsWithUnclaimedRewards: null,\n      allWinningTickets,\n      cakeTotal: null,\n      roundId\n    };\n  }\n\n  return null;\n};\n\nconst getWinningNumbersForRound = (targetRoundId, lotteriesData) => {\n  const targetRound = lotteriesData.find(pastLottery => pastLottery.id === targetRoundId);\n  return targetRound === null || targetRound === void 0 ? void 0 : targetRound.finalNumber;\n};\n\nexport const fetchUserTicketsForMultipleRounds = async (roundsToCheck, account) => {\n  // Build calls with data to help with merging multicall responses\n  const callsWithRoundData = roundsToCheck.map(round => {\n    const totalTickets = parseInt(round.totalTickets, 10);\n    const calls = getViewUserTicketInfoCalls(totalTickets, account, round.lotteryId);\n    return {\n      calls,\n      lotteryId: round.lotteryId,\n      count: calls.length\n    };\n  }); // Batch all calls across all rounds\n\n  const multicalls = [].concat(...callsWithRoundData.map(callWithRoundData => callWithRoundData.calls));\n\n  try {\n    const multicallRes = await multicallv2(lotteryV2Abi, multicalls, {\n      requireSuccess: false\n    }); // Use callsWithRoundData to slice multicall responses by round\n\n    const multicallResPerRound = [];\n    let resCount = 0;\n\n    for (let i = 0; i < callsWithRoundData.length; i += 1) {\n      const callOptions = callsWithRoundData[i];\n      multicallResPerRound.push(multicallRes.slice(resCount, resCount + callOptions.count));\n      resCount += callOptions.count;\n    }\n\n    const mergedMulticallResponse = multicallResPerRound.map(res => mergeViewUserTicketInfoMulticallResponse(res));\n    return mergedMulticallResponse;\n  } catch (error) {\n    console.error(error);\n    return [];\n  }\n};\n\nconst fetchUnclaimedUserRewards = async (account, userLotteryData, lotteriesData) => {\n  const {\n    rounds\n  } = userLotteryData; // If there is no user round history - return an empty array\n\n  if (rounds.length === 0) {\n    return [];\n  } // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\n\n\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\n    return [];\n  } // Filter out non-claimable rounds\n\n\n  const claimableRounds = rounds.filter(round => {\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE;\n  }); // If there are any rounds tickets haven't been claimed for, OR a user has over 100 tickets in a round - check user tickets for those rounds\n\n  const roundsToCheck = claimableRounds.filter(round => {\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100;\n  });\n\n  if (roundsToCheck.length > 0) {\n    const rawUserTicketData = await fetchUserTicketsForMultipleRounds(roundsToCheck, account);\n\n    if (rawUserTicketData.length === 0) {\n      // In case of error with ticket calls, return empty array\n      return [];\n    }\n\n    const roundIds = roundsToCheck.map(round => round.lotteryId);\n    const roundDataAndUserTickets = rawUserTicketData.map((rawRoundTicketData, index) => {\n      return {\n        roundId: roundIds[index],\n        userTickets: processRawTicketsResponse(rawRoundTicketData),\n        finalNumber: getWinningNumbersForRound(roundIds[index], lotteriesData)\n      };\n    });\n    const winningTicketsForPastRounds = await Promise.all(roundDataAndUserTickets.map(roundData => getWinningTickets(roundData))); // Filter out null values (returned when no winning tickets found for past round)\n\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(winningTicketData => winningTicketData !== null); // Filter to only rounds with unclaimed tickets\n\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(winningTicketData => winningTicketData.ticketsWithUnclaimedRewards);\n    return roundsWithUnclaimedWinningTickets;\n  } // All rounds claimed, return empty array\n\n\n  return [];\n};\n\nexport default fetchUnclaimedUserRewards;","map":{"version":3,"sources":["/home/kodachi/Desktop/Frontend1/src/state/lottery/fetchUnclaimedUserRewards.ts"],"names":["BigNumber","LotteryStatus","multicallv2","lotteryV2Abi","getLotteryV2Address","BIG_ZERO","getViewUserTicketInfoCalls","mergeViewUserTicketInfoMulticallResponse","processRawTicketsResponse","lotteryAddress","fetchCakeRewardsForTickets","winningTickets","calls","map","winningTicket","roundId","id","rewardBracket","name","address","params","cakeRewards","cakeTotal","reduce","accum","cakeReward","plus","toString","ticketsWithUnclaimedRewards","index","getRewardBracketByNumber","ticketNumber","finalNumber","ticketNumAsArray","split","reverse","winningNumsAsArray","matchingNumbers","length","push","getWinningTickets","roundDataAndUserTickets","userTickets","ticketsWithRewardBrackets","ticket","number","status","allWinningTickets","filter","unclaimedWinningTickets","getWinningNumbersForRound","targetRoundId","lotteriesData","targetRound","find","pastLottery","fetchUserTicketsForMultipleRounds","roundsToCheck","account","callsWithRoundData","round","totalTickets","parseInt","lotteryId","count","multicalls","concat","callWithRoundData","multicallRes","requireSuccess","multicallResPerRound","resCount","i","callOptions","slice","mergedMulticallResponse","res","error","console","fetchUnclaimedUserRewards","userLotteryData","rounds","toLowerCase","claimableRounds","CLAIMABLE","claimed","rawUserTicketData","roundIds","rawRoundTicketData","winningTicketsForPastRounds","Promise","all","roundData","roundsWithWinningTickets","winningTicketData","roundsWithUnclaimedWinningTickets"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\nimport { ethers } from 'ethers'\nimport { LotteryStatus, LotteryTicket, LotteryTicketClaimData } from 'config/constants/types'\nimport { LotteryUserGraphEntity, LotteryRoundGraphEntity, UserRound } from 'state/types'\nimport { multicallv2 } from 'utils/multicall'\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\nimport { getLotteryV2Address } from 'utils/addressHelpers'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport {\n  getViewUserTicketInfoCalls,\n  mergeViewUserTicketInfoMulticallResponse,\n  processRawTicketsResponse,\n} from './helpers'\n\ninterface RoundDataAndUserTickets {\n  roundId: string\n  userTickets: LotteryTicket[]\n  finalNumber: string\n}\n\nconst lotteryAddress = getLotteryV2Address()\n\nconst fetchCakeRewardsForTickets = async (\n  winningTickets: LotteryTicket[],\n): Promise<{ ticketsWithUnclaimedRewards: LotteryTicket[]; cakeTotal: BigNumber }> => {\n  const calls = winningTickets.map((winningTicket) => {\n    const { roundId, id, rewardBracket } = winningTicket\n    return {\n      name: 'viewRewardsForTicketId',\n      address: lotteryAddress,\n      params: [roundId, id, rewardBracket],\n    }\n  })\n  const cakeRewards = await multicallv2(lotteryV2Abi, calls)\n\n  const cakeTotal = cakeRewards.reduce((accum: BigNumber, cakeReward: ethers.BigNumber[]) => {\n    return accum.plus(new BigNumber(cakeReward[0].toString()))\n  }, BIG_ZERO)\n\n  const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\n    return { ...winningTicket, cakeReward: cakeRewards[index] }\n  })\n  return { ticketsWithUnclaimedRewards, cakeTotal }\n}\n\nconst getRewardBracketByNumber = (ticketNumber: string, finalNumber: string): number => {\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n  // i.e. '1123456' should be evaluated as '6543211'\n  const ticketNumAsArray = ticketNumber.split('').reverse()\n  const winningNumsAsArray = finalNumber.split('').reverse()\n  const matchingNumbers = []\n\n  // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\n      break\n    }\n    matchingNumbers.push(ticketNumAsArray[index])\n  }\n\n  // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\n  const rewardBracket = matchingNumbers.length - 1\n  return rewardBracket\n}\n\nexport const getWinningTickets = async (\n  roundDataAndUserTickets: RoundDataAndUserTickets,\n): Promise<LotteryTicketClaimData> => {\n  const { roundId, userTickets, finalNumber } = roundDataAndUserTickets\n\n  const ticketsWithRewardBrackets = userTickets.map((ticket) => {\n    return {\n      roundId,\n      id: ticket.id,\n      number: ticket.number,\n      status: ticket.status,\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber),\n    }\n  })\n\n  // A rewardBracket of -1 means no matches. 0 and above means there has been a match\n  const allWinningTickets = ticketsWithRewardBrackets.filter((ticket) => {\n    return ticket.rewardBracket >= 0\n  })\n\n  // If ticket.status is true, the ticket has already been claimed\n  const unclaimedWinningTickets = allWinningTickets.filter((ticket) => {\n    return !ticket.status\n  })\n\n  if (unclaimedWinningTickets.length > 0) {\n    const { ticketsWithUnclaimedRewards, cakeTotal } = await fetchCakeRewardsForTickets(unclaimedWinningTickets)\n    return { ticketsWithUnclaimedRewards, allWinningTickets, cakeTotal, roundId }\n  }\n\n  if (allWinningTickets.length > 0) {\n    return { ticketsWithUnclaimedRewards: null, allWinningTickets, cakeTotal: null, roundId }\n  }\n\n  return null\n}\n\nconst getWinningNumbersForRound = (targetRoundId: string, lotteriesData: LotteryRoundGraphEntity[]) => {\n  const targetRound = lotteriesData.find((pastLottery) => pastLottery.id === targetRoundId)\n  return targetRound?.finalNumber\n}\n\nexport const fetchUserTicketsForMultipleRounds = async (roundsToCheck: UserRound[], account: string) => {\n  // Build calls with data to help with merging multicall responses\n  const callsWithRoundData = roundsToCheck.map((round) => {\n    const totalTickets = parseInt(round.totalTickets, 10)\n    const calls = getViewUserTicketInfoCalls(totalTickets, account, round.lotteryId)\n    return { calls, lotteryId: round.lotteryId, count: calls.length }\n  })\n\n  // Batch all calls across all rounds\n  const multicalls = [].concat(...callsWithRoundData.map((callWithRoundData) => callWithRoundData.calls))\n\n  try {\n    const multicallRes = await multicallv2(lotteryV2Abi, multicalls, { requireSuccess: false })\n\n    // Use callsWithRoundData to slice multicall responses by round\n    const multicallResPerRound = []\n    let resCount = 0\n    for (let i = 0; i < callsWithRoundData.length; i += 1) {\n      const callOptions = callsWithRoundData[i]\n\n      multicallResPerRound.push(multicallRes.slice(resCount, resCount + callOptions.count))\n      resCount += callOptions.count\n    }\n    const mergedMulticallResponse = multicallResPerRound.map((res) => mergeViewUserTicketInfoMulticallResponse(res))\n\n    return mergedMulticallResponse\n  } catch (error) {\n    console.error(error)\n    return []\n  }\n}\n\nconst fetchUnclaimedUserRewards = async (\n  account: string,\n  userLotteryData: LotteryUserGraphEntity,\n  lotteriesData: LotteryRoundGraphEntity[],\n): Promise<LotteryTicketClaimData[]> => {\n  const { rounds } = userLotteryData\n\n  // If there is no user round history - return an empty array\n  if (rounds.length === 0) {\n    return []\n  }\n\n  // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\n    return []\n  }\n\n  // Filter out non-claimable rounds\n  const claimableRounds = rounds.filter((round) => {\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE\n  })\n\n  // If there are any rounds tickets haven't been claimed for, OR a user has over 100 tickets in a round - check user tickets for those rounds\n  const roundsToCheck = claimableRounds.filter((round) => {\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100\n  })\n\n  if (roundsToCheck.length > 0) {\n    const rawUserTicketData = await fetchUserTicketsForMultipleRounds(roundsToCheck, account)\n\n    if (rawUserTicketData.length === 0) {\n      // In case of error with ticket calls, return empty array\n      return []\n    }\n\n    const roundIds = roundsToCheck.map((round) => round.lotteryId)\n    const roundDataAndUserTickets = rawUserTicketData.map((rawRoundTicketData, index) => {\n      return {\n        roundId: roundIds[index],\n        userTickets: processRawTicketsResponse(rawRoundTicketData),\n        finalNumber: getWinningNumbersForRound(roundIds[index], lotteriesData),\n      }\n    })\n\n    const winningTicketsForPastRounds = await Promise.all(\n      roundDataAndUserTickets.map((roundData) => getWinningTickets(roundData)),\n    )\n\n    // Filter out null values (returned when no winning tickets found for past round)\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(\n      (winningTicketData) => winningTicketData !== null,\n    )\n\n    // Filter to only rounds with unclaimed tickets\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(\n      (winningTicketData) => winningTicketData.ticketsWithUnclaimedRewards,\n    )\n\n    return roundsWithUnclaimedWinningTickets\n  }\n  // All rounds claimed, return empty array\n  return []\n}\n\nexport default fetchUnclaimedUserRewards\n"]},"metadata":{},"sourceType":"module"}