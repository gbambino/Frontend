{"ast":null,"code":"import _toConsumableArray from\"/home/kodachi/Desktop/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _regeneratorRuntime from\"/home/kodachi/Desktop/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/home/kodachi/Desktop/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/home/kodachi/Desktop/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import BigNumber from'bignumber.js';import{LotteryStatus}from'config/constants/types';import{multicallv2}from'utils/multicall';import lotteryV2Abi from'config/abi/lotteryV2.json';import{getLotteryV2Address}from'utils/addressHelpers';import{BIG_ZERO}from'utils/bigNumber';import{getViewUserTicketInfoCalls,mergeViewUserTicketInfoMulticallResponse,processRawTicketsResponse}from'./helpers';var lotteryAddress=getLotteryV2Address();var fetchCakeRewardsForTickets=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(winningTickets){var calls,cakeRewards,cakeTotal,ticketsWithUnclaimedRewards;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:calls=winningTickets.map(function(winningTicket){var roundId=winningTicket.roundId,id=winningTicket.id,rewardBracket=winningTicket.rewardBracket;return{name:'viewRewardsForTicketId',address:lotteryAddress,params:[roundId,id,rewardBracket]};});_context.next=3;return multicallv2(lotteryV2Abi,calls);case 3:cakeRewards=_context.sent;cakeTotal=cakeRewards.reduce(function(accum,cakeReward){return accum.plus(new BigNumber(cakeReward[0].toString()));},BIG_ZERO);ticketsWithUnclaimedRewards=winningTickets.map(function(winningTicket,index){return _objectSpread(_objectSpread({},winningTicket),{},{cakeReward:cakeRewards[index]});});return _context.abrupt(\"return\",{ticketsWithUnclaimedRewards:ticketsWithUnclaimedRewards,cakeTotal:cakeTotal});case 7:case\"end\":return _context.stop();}}},_callee);}));return function fetchCakeRewardsForTickets(_x){return _ref.apply(this,arguments);};}();var getRewardBracketByNumber=function getRewardBracketByNumber(ticketNumber,finalNumber){// Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n// i.e. '1123456' should be evaluated as '6543211'\nvar ticketNumAsArray=ticketNumber.split('').reverse();var winningNumsAsArray=finalNumber.split('').reverse();var matchingNumbers=[];// The number at index 6 in all tickets is 1 and will always match, so finish at index 5\nfor(var index=0;index<winningNumsAsArray.length-1;index++){if(ticketNumAsArray[index]!==winningNumsAsArray[index]){break;}matchingNumbers.push(ticketNumAsArray[index]);}// Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\nvar rewardBracket=matchingNumbers.length-1;return rewardBracket;};export var getWinningTickets=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(roundDataAndUserTickets){var roundId,userTickets,finalNumber,ticketsWithRewardBrackets,allWinningTickets,unclaimedWinningTickets,_yield$fetchCakeRewar,ticketsWithUnclaimedRewards,cakeTotal;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:roundId=roundDataAndUserTickets.roundId,userTickets=roundDataAndUserTickets.userTickets,finalNumber=roundDataAndUserTickets.finalNumber;ticketsWithRewardBrackets=userTickets.map(function(ticket){return{roundId:roundId,id:ticket.id,number:ticket.number,status:ticket.status,rewardBracket:getRewardBracketByNumber(ticket.number,finalNumber)};});// A rewardBracket of -1 means no matches. 0 and above means there has been a match\nallWinningTickets=ticketsWithRewardBrackets.filter(function(ticket){return ticket.rewardBracket>=0;});// If ticket.status is true, the ticket has already been claimed\nunclaimedWinningTickets=allWinningTickets.filter(function(ticket){return!ticket.status;});if(!(unclaimedWinningTickets.length>0)){_context2.next=11;break;}_context2.next=7;return fetchCakeRewardsForTickets(unclaimedWinningTickets);case 7:_yield$fetchCakeRewar=_context2.sent;ticketsWithUnclaimedRewards=_yield$fetchCakeRewar.ticketsWithUnclaimedRewards;cakeTotal=_yield$fetchCakeRewar.cakeTotal;return _context2.abrupt(\"return\",{ticketsWithUnclaimedRewards:ticketsWithUnclaimedRewards,allWinningTickets:allWinningTickets,cakeTotal:cakeTotal,roundId:roundId});case 11:if(!(allWinningTickets.length>0)){_context2.next=13;break;}return _context2.abrupt(\"return\",{ticketsWithUnclaimedRewards:null,allWinningTickets:allWinningTickets,cakeTotal:null,roundId:roundId});case 13:return _context2.abrupt(\"return\",null);case 14:case\"end\":return _context2.stop();}}},_callee2);}));return function getWinningTickets(_x2){return _ref2.apply(this,arguments);};}();var getWinningNumbersForRound=function getWinningNumbersForRound(targetRoundId,lotteriesData){var targetRound=lotteriesData.find(function(pastLottery){return pastLottery.id===targetRoundId;});return targetRound===null||targetRound===void 0?void 0:targetRound.finalNumber;};export var fetchUserTicketsForMultipleRounds=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(roundsToCheck,account){var _ref4;var callsWithRoundData,multicalls,multicallRes,multicallResPerRound,resCount,i,callOptions,mergedMulticallResponse;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:// Build calls with data to help with merging multicall responses\ncallsWithRoundData=roundsToCheck.map(function(round){var totalTickets=parseInt(round.totalTickets,10);var calls=getViewUserTicketInfoCalls(totalTickets,account,round.lotteryId);return{calls:calls,lotteryId:round.lotteryId,count:calls.length};});// Batch all calls across all rounds\nmulticalls=(_ref4=[]).concat.apply(_ref4,_toConsumableArray(callsWithRoundData.map(function(callWithRoundData){return callWithRoundData.calls;})));_context3.prev=2;_context3.next=5;return multicallv2(lotteryV2Abi,multicalls,{requireSuccess:false});case 5:multicallRes=_context3.sent;// Use callsWithRoundData to slice multicall responses by round\nmulticallResPerRound=[];resCount=0;for(i=0;i<callsWithRoundData.length;i+=1){callOptions=callsWithRoundData[i];multicallResPerRound.push(multicallRes.slice(resCount,resCount+callOptions.count));resCount+=callOptions.count;}mergedMulticallResponse=multicallResPerRound.map(function(res){return mergeViewUserTicketInfoMulticallResponse(res);});return _context3.abrupt(\"return\",mergedMulticallResponse);case 13:_context3.prev=13;_context3.t0=_context3[\"catch\"](2);console.error(_context3.t0);return _context3.abrupt(\"return\",[]);case 17:case\"end\":return _context3.stop();}}},_callee3,null,[[2,13]]);}));return function fetchUserTicketsForMultipleRounds(_x3,_x4){return _ref3.apply(this,arguments);};}();var fetchUnclaimedUserRewards=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(account,userLotteryData,lotteriesData){var rounds,claimableRounds,roundsToCheck,rawUserTicketData,roundIds,roundDataAndUserTickets,winningTicketsForPastRounds,roundsWithWinningTickets,roundsWithUnclaimedWinningTickets;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:rounds=userLotteryData.rounds;// If there is no user round history - return an empty array\nif(!(rounds.length===0)){_context4.next=3;break;}return _context4.abrupt(\"return\",[]);case 3:if(!(userLotteryData.account.toLowerCase()!==account.toLowerCase())){_context4.next=5;break;}return _context4.abrupt(\"return\",[]);case 5:// Filter out non-claimable rounds\nclaimableRounds=rounds.filter(function(round){return round.status.toLowerCase()===LotteryStatus.CLAIMABLE;});// If there are any rounds tickets haven't been claimed for, OR a user has over 100 tickets in a round - check user tickets for those rounds\nroundsToCheck=claimableRounds.filter(function(round){return!round.claimed||parseInt(round.totalTickets,10)>100;});if(!(roundsToCheck.length>0)){_context4.next=21;break;}_context4.next=10;return fetchUserTicketsForMultipleRounds(roundsToCheck,account);case 10:rawUserTicketData=_context4.sent;if(!(rawUserTicketData.length===0)){_context4.next=13;break;}return _context4.abrupt(\"return\",[]);case 13:roundIds=roundsToCheck.map(function(round){return round.lotteryId;});roundDataAndUserTickets=rawUserTicketData.map(function(rawRoundTicketData,index){return{roundId:roundIds[index],userTickets:processRawTicketsResponse(rawRoundTicketData),finalNumber:getWinningNumbersForRound(roundIds[index],lotteriesData)};});_context4.next=17;return Promise.all(roundDataAndUserTickets.map(function(roundData){return getWinningTickets(roundData);}));case 17:winningTicketsForPastRounds=_context4.sent;// Filter out null values (returned when no winning tickets found for past round)\nroundsWithWinningTickets=winningTicketsForPastRounds.filter(function(winningTicketData){return winningTicketData!==null;});// Filter to only rounds with unclaimed tickets\nroundsWithUnclaimedWinningTickets=roundsWithWinningTickets.filter(function(winningTicketData){return winningTicketData.ticketsWithUnclaimedRewards;});return _context4.abrupt(\"return\",roundsWithUnclaimedWinningTickets);case 21:return _context4.abrupt(\"return\",[]);case 22:case\"end\":return _context4.stop();}}},_callee4);}));return function fetchUnclaimedUserRewards(_x5,_x6,_x7){return _ref5.apply(this,arguments);};}();export default fetchUnclaimedUserRewards;","map":{"version":3,"sources":["/home/kodachi/Desktop/Frontend1/src/state/lottery/fetchUnclaimedUserRewards.ts"],"names":["BigNumber","LotteryStatus","multicallv2","lotteryV2Abi","getLotteryV2Address","BIG_ZERO","getViewUserTicketInfoCalls","mergeViewUserTicketInfoMulticallResponse","processRawTicketsResponse","lotteryAddress","fetchCakeRewardsForTickets","winningTickets","calls","map","winningTicket","roundId","id","rewardBracket","name","address","params","cakeRewards","cakeTotal","reduce","accum","cakeReward","plus","toString","ticketsWithUnclaimedRewards","index","getRewardBracketByNumber","ticketNumber","finalNumber","ticketNumAsArray","split","reverse","winningNumsAsArray","matchingNumbers","length","push","getWinningTickets","roundDataAndUserTickets","userTickets","ticketsWithRewardBrackets","ticket","number","status","allWinningTickets","filter","unclaimedWinningTickets","getWinningNumbersForRound","targetRoundId","lotteriesData","targetRound","find","pastLottery","fetchUserTicketsForMultipleRounds","roundsToCheck","account","callsWithRoundData","round","totalTickets","parseInt","lotteryId","count","multicalls","concat","callWithRoundData","requireSuccess","multicallRes","multicallResPerRound","resCount","i","callOptions","slice","mergedMulticallResponse","res","console","error","fetchUnclaimedUserRewards","userLotteryData","rounds","toLowerCase","claimableRounds","CLAIMABLE","claimed","rawUserTicketData","roundIds","rawRoundTicketData","Promise","all","roundData","winningTicketsForPastRounds","roundsWithWinningTickets","winningTicketData","roundsWithUnclaimedWinningTickets"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\nimport { ethers } from 'ethers'\nimport { LotteryStatus, LotteryTicket, LotteryTicketClaimData } from 'config/constants/types'\nimport { LotteryUserGraphEntity, LotteryRoundGraphEntity, UserRound } from 'state/types'\nimport { multicallv2 } from 'utils/multicall'\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\nimport { getLotteryV2Address } from 'utils/addressHelpers'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport {\n  getViewUserTicketInfoCalls,\n  mergeViewUserTicketInfoMulticallResponse,\n  processRawTicketsResponse,\n} from './helpers'\n\ninterface RoundDataAndUserTickets {\n  roundId: string\n  userTickets: LotteryTicket[]\n  finalNumber: string\n}\n\nconst lotteryAddress = getLotteryV2Address()\n\nconst fetchCakeRewardsForTickets = async (\n  winningTickets: LotteryTicket[],\n): Promise<{ ticketsWithUnclaimedRewards: LotteryTicket[]; cakeTotal: BigNumber }> => {\n  const calls = winningTickets.map((winningTicket) => {\n    const { roundId, id, rewardBracket } = winningTicket\n    return {\n      name: 'viewRewardsForTicketId',\n      address: lotteryAddress,\n      params: [roundId, id, rewardBracket],\n    }\n  })\n  const cakeRewards = await multicallv2(lotteryV2Abi, calls)\n\n  const cakeTotal = cakeRewards.reduce((accum: BigNumber, cakeReward: ethers.BigNumber[]) => {\n    return accum.plus(new BigNumber(cakeReward[0].toString()))\n  }, BIG_ZERO)\n\n  const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\n    return { ...winningTicket, cakeReward: cakeRewards[index] }\n  })\n  return { ticketsWithUnclaimedRewards, cakeTotal }\n}\n\nconst getRewardBracketByNumber = (ticketNumber: string, finalNumber: string): number => {\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n  // i.e. '1123456' should be evaluated as '6543211'\n  const ticketNumAsArray = ticketNumber.split('').reverse()\n  const winningNumsAsArray = finalNumber.split('').reverse()\n  const matchingNumbers = []\n\n  // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\n      break\n    }\n    matchingNumbers.push(ticketNumAsArray[index])\n  }\n\n  // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\n  const rewardBracket = matchingNumbers.length - 1\n  return rewardBracket\n}\n\nexport const getWinningTickets = async (\n  roundDataAndUserTickets: RoundDataAndUserTickets,\n): Promise<LotteryTicketClaimData> => {\n  const { roundId, userTickets, finalNumber } = roundDataAndUserTickets\n\n  const ticketsWithRewardBrackets = userTickets.map((ticket) => {\n    return {\n      roundId,\n      id: ticket.id,\n      number: ticket.number,\n      status: ticket.status,\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber),\n    }\n  })\n\n  // A rewardBracket of -1 means no matches. 0 and above means there has been a match\n  const allWinningTickets = ticketsWithRewardBrackets.filter((ticket) => {\n    return ticket.rewardBracket >= 0\n  })\n\n  // If ticket.status is true, the ticket has already been claimed\n  const unclaimedWinningTickets = allWinningTickets.filter((ticket) => {\n    return !ticket.status\n  })\n\n  if (unclaimedWinningTickets.length > 0) {\n    const { ticketsWithUnclaimedRewards, cakeTotal } = await fetchCakeRewardsForTickets(unclaimedWinningTickets)\n    return { ticketsWithUnclaimedRewards, allWinningTickets, cakeTotal, roundId }\n  }\n\n  if (allWinningTickets.length > 0) {\n    return { ticketsWithUnclaimedRewards: null, allWinningTickets, cakeTotal: null, roundId }\n  }\n\n  return null\n}\n\nconst getWinningNumbersForRound = (targetRoundId: string, lotteriesData: LotteryRoundGraphEntity[]) => {\n  const targetRound = lotteriesData.find((pastLottery) => pastLottery.id === targetRoundId)\n  return targetRound?.finalNumber\n}\n\nexport const fetchUserTicketsForMultipleRounds = async (roundsToCheck: UserRound[], account: string) => {\n  // Build calls with data to help with merging multicall responses\n  const callsWithRoundData = roundsToCheck.map((round) => {\n    const totalTickets = parseInt(round.totalTickets, 10)\n    const calls = getViewUserTicketInfoCalls(totalTickets, account, round.lotteryId)\n    return { calls, lotteryId: round.lotteryId, count: calls.length }\n  })\n\n  // Batch all calls across all rounds\n  const multicalls = [].concat(...callsWithRoundData.map((callWithRoundData) => callWithRoundData.calls))\n\n  try {\n    const multicallRes = await multicallv2(lotteryV2Abi, multicalls, { requireSuccess: false })\n\n    // Use callsWithRoundData to slice multicall responses by round\n    const multicallResPerRound = []\n    let resCount = 0\n    for (let i = 0; i < callsWithRoundData.length; i += 1) {\n      const callOptions = callsWithRoundData[i]\n\n      multicallResPerRound.push(multicallRes.slice(resCount, resCount + callOptions.count))\n      resCount += callOptions.count\n    }\n    const mergedMulticallResponse = multicallResPerRound.map((res) => mergeViewUserTicketInfoMulticallResponse(res))\n\n    return mergedMulticallResponse\n  } catch (error) {\n    console.error(error)\n    return []\n  }\n}\n\nconst fetchUnclaimedUserRewards = async (\n  account: string,\n  userLotteryData: LotteryUserGraphEntity,\n  lotteriesData: LotteryRoundGraphEntity[],\n): Promise<LotteryTicketClaimData[]> => {\n  const { rounds } = userLotteryData\n\n  // If there is no user round history - return an empty array\n  if (rounds.length === 0) {\n    return []\n  }\n\n  // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\n    return []\n  }\n\n  // Filter out non-claimable rounds\n  const claimableRounds = rounds.filter((round) => {\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE\n  })\n\n  // If there are any rounds tickets haven't been claimed for, OR a user has over 100 tickets in a round - check user tickets for those rounds\n  const roundsToCheck = claimableRounds.filter((round) => {\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100\n  })\n\n  if (roundsToCheck.length > 0) {\n    const rawUserTicketData = await fetchUserTicketsForMultipleRounds(roundsToCheck, account)\n\n    if (rawUserTicketData.length === 0) {\n      // In case of error with ticket calls, return empty array\n      return []\n    }\n\n    const roundIds = roundsToCheck.map((round) => round.lotteryId)\n    const roundDataAndUserTickets = rawUserTicketData.map((rawRoundTicketData, index) => {\n      return {\n        roundId: roundIds[index],\n        userTickets: processRawTicketsResponse(rawRoundTicketData),\n        finalNumber: getWinningNumbersForRound(roundIds[index], lotteriesData),\n      }\n    })\n\n    const winningTicketsForPastRounds = await Promise.all(\n      roundDataAndUserTickets.map((roundData) => getWinningTickets(roundData)),\n    )\n\n    // Filter out null values (returned when no winning tickets found for past round)\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(\n      (winningTicketData) => winningTicketData !== null,\n    )\n\n    // Filter to only rounds with unclaimed tickets\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(\n      (winningTicketData) => winningTicketData.ticketsWithUnclaimedRewards,\n    )\n\n    return roundsWithUnclaimedWinningTickets\n  }\n  // All rounds claimed, return empty array\n  return []\n}\n\nexport default fetchUnclaimedUserRewards\n"]},"metadata":{},"sourceType":"module"}