{"ast":null,"code":"import _regeneratorRuntime from\"/home/kodachi/Desktop/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _defineProperty from\"/home/kodachi/Desktop/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/home/kodachi/Desktop/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/home/kodachi/Desktop/Frontend1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/* eslint-disable no-param-reassign */import{createAsyncThunk,createSlice}from'@reduxjs/toolkit';import maxBy from'lodash/maxBy';import merge from'lodash/merge';import range from'lodash/range';import{BIG_ZERO}from'utils/bigNumber';import{HistoryFilter,PredictionStatus}from'state/types';import{getPredictionsContract}from'utils/contractHelpers';import{getBetHistory,transformBetResponse,makeFutureRoundResponse,makeRoundData,getRoundsData,getPredictionData,getLedgerData,makeLedgerData,serializePredictionsRoundsResponse,getClaimStatuses}from'./helpers';var PAST_ROUND_COUNT=5;var FUTURE_ROUND_COUNT=2;// The estimated time it takes to broadcast\nexport var BLOCK_PADDING=3;var initialState={status:PredictionStatus.INITIAL,isLoading:false,isHistoryPaneOpen:false,isChartPaneOpen:false,isFetchingHistory:false,historyFilter:HistoryFilter.ALL,currentEpoch:0,currentRoundStartBlockNumber:0,intervalBlocks:100,bufferBlocks:20,minBetAmount:'1000000000000000',rewardRate:97,lastOraclePrice:BIG_ZERO.toJSON(),rounds:{},history:{},ledgers:{},claimableStatuses:{}};// Thunks\n// V2 REFACTOR\nexport var initializePredictions=createAsyncThunk('predictions/intialize',/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var account,marketData,epochs,roundsResponse,initialRoundData,initializedData,ledgerResponses,claimableStatuses,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:account=_args.length>0&&_args[0]!==undefined?_args[0]:null;_context.next=3;return getPredictionData();case 3:marketData=_context.sent;epochs=range(marketData.currentEpoch,marketData.currentEpoch-PAST_ROUND_COUNT);// Round data\n_context.next=7;return getRoundsData(epochs);case 7:roundsResponse=_context.sent;initialRoundData=roundsResponse.reduce(function(accum,roundResponse){var reduxNodeRound=serializePredictionsRoundsResponse(roundResponse);return _objectSpread(_objectSpread({},accum),{},_defineProperty({},reduxNodeRound.epoch.toString(),reduxNodeRound));},{});initializedData=_objectSpread(_objectSpread({},marketData),{},{rounds:initialRoundData,ledgers:{},claimableStatuses:{}});if(account){_context.next=12;break;}return _context.abrupt(\"return\",initializedData);case 12:_context.next=14;return getLedgerData(account,epochs);case 14:ledgerResponses=_context.sent;_context.next=17;return getClaimStatuses(account,epochs);case 17:claimableStatuses=_context.sent;return _context.abrupt(\"return\",merge({},initializedData,{ledgers:makeLedgerData(account,ledgerResponses,epochs),claimableStatuses:claimableStatuses}));case 19:case\"end\":return _context.stop();}}},_callee);})));export var fetchRound=createAsyncThunk('predictions/fetchRound',/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(epoch){var predictionContract,response;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:predictionContract=getPredictionsContract();_context2.next=3;return predictionContract.rounds(epoch);case 3:response=_context2.sent;return _context2.abrupt(\"return\",serializePredictionsRoundsResponse(response));case 5:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x){return _ref2.apply(this,arguments);};}());export var fetchRounds=createAsyncThunk('predictions/fetchRounds',/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(epochs){var rounds;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return getRoundsData(epochs);case 2:rounds=_context3.sent;return _context3.abrupt(\"return\",rounds.reduce(function(accum,round){if(!round){return accum;}var reduxNodeRound=serializePredictionsRoundsResponse(round);return _objectSpread(_objectSpread({},accum),{},_defineProperty({},reduxNodeRound.epoch.toString(),reduxNodeRound));},{}));case 4:case\"end\":return _context3.stop();}}},_callee3);}));return function(_x2){return _ref3.apply(this,arguments);};}());export var fetchMarketData=createAsyncThunk('predictions/fetchMarketData',/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(){var marketData;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return getPredictionData();case 2:marketData=_context4.sent;return _context4.abrupt(\"return\",marketData);case 4:case\"end\":return _context4.stop();}}},_callee4);})));export var fetchLedgerData=createAsyncThunk('predictions/fetchLedgerData',/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref5){var account,epochs,ledgers;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:account=_ref5.account,epochs=_ref5.epochs;_context5.next=3;return getLedgerData(account,epochs);case 3:ledgers=_context5.sent;return _context5.abrupt(\"return\",makeLedgerData(account,ledgers,epochs));case 5:case\"end\":return _context5.stop();}}},_callee5);}));return function(_x3){return _ref6.apply(this,arguments);};}());export var fetchClaimableStatuses=createAsyncThunk('predictions/fetchClaimableStatuses',/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref7){var account,epochs,ledgers;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:account=_ref7.account,epochs=_ref7.epochs;_context6.next=3;return getClaimStatuses(account,epochs);case 3:ledgers=_context6.sent;return _context6.abrupt(\"return\",ledgers);case 5:case\"end\":return _context6.stop();}}},_callee6);}));return function(_x4){return _ref8.apply(this,arguments);};}());// END V2 REFACTOR\nexport var fetchHistory=createAsyncThunk('predictions/fetchHistory',/*#__PURE__*/function(){var _ref10=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(_ref9){var account,claimed,response,bets;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:account=_ref9.account,claimed=_ref9.claimed;_context7.next=3;return getBetHistory({user:account.toLowerCase(),claimed:claimed});case 3:response=_context7.sent;bets=response.map(transformBetResponse);return _context7.abrupt(\"return\",{account:account,bets:bets});case 6:case\"end\":return _context7.stop();}}},_callee7);}));return function(_x5){return _ref10.apply(this,arguments);};}());export var predictionsSlice=createSlice({name:'predictions',initialState:initialState,reducers:{setPredictionStatus:function setPredictionStatus(state,action){state.status=action.payload;},setHistoryPaneState:function setHistoryPaneState(state,action){state.isHistoryPaneOpen=action.payload;state.historyFilter=HistoryFilter.ALL;},setChartPaneState:function setChartPaneState(state,action){state.isChartPaneOpen=action.payload;},setHistoryFilter:function setHistoryFilter(state,action){state.historyFilter=action.payload;},setCurrentEpoch:function setCurrentEpoch(state,action){state.currentEpoch=action.payload;},setLastOraclePrice:function setLastOraclePrice(state,action){state.lastOraclePrice=action.payload;},markBetHistoryAsCollected:function markBetHistoryAsCollected(state,action){var _action$payload=action.payload,account=_action$payload.account,betId=_action$payload.betId;if(state.history[account]){var betIndex=state.history[account].findIndex(function(bet){return bet.id===betId;});if(betIndex>=0){state.history[account][betIndex].claimed=true;}}}},extraReducers:function extraReducers(builder){// Claimable statuses\nbuilder.addCase(fetchClaimableStatuses.fulfilled,function(state,action){state.claimableStatuses=merge({},state.claimableStatuses,action.payload);});// Ledger (bet) records\nbuilder.addCase(fetchLedgerData.fulfilled,function(state,action){state.ledgers=merge({},state.ledgers,action.payload);});// Get static market data\nbuilder.addCase(fetchMarketData.fulfilled,function(state,action){var _action$payload2=action.payload,status=_action$payload2.status,currentEpoch=_action$payload2.currentEpoch,intervalBlocks=_action$payload2.intervalBlocks,bufferBlocks=_action$payload2.bufferBlocks,minBetAmount=_action$payload2.minBetAmount,rewardRate=_action$payload2.rewardRate;// If the round has change add a new future round\nif(state.currentEpoch!==currentEpoch){var newestRound=maxBy(Object.values(state.rounds),'epoch');var futureRound=makeFutureRoundResponse(newestRound.epoch+1,newestRound.startBlock+(state.intervalBlocks+BLOCK_PADDING));state.rounds[futureRound.epoch]=futureRound;state.currentRoundStartBlockNumber=state.currentRoundStartBlockNumber+state.intervalBlocks+BLOCK_PADDING;}state.status=status;state.currentEpoch=currentEpoch;state.intervalBlocks=intervalBlocks;state.bufferBlocks=bufferBlocks;state.minBetAmount=minBetAmount;state.rewardRate=rewardRate;});// Initialize predictions\nbuilder.addCase(initializePredictions.fulfilled,function(state,action){var _action$payload3=action.payload,status=_action$payload3.status,currentEpoch=_action$payload3.currentEpoch,bufferBlocks=_action$payload3.bufferBlocks,intervalBlocks=_action$payload3.intervalBlocks,rounds=_action$payload3.rounds,claimableStatuses=_action$payload3.claimableStatuses,rewardRate=_action$payload3.rewardRate,ledgers=_action$payload3.ledgers;var currentRoundStartBlockNumber=action.payload.rounds[currentEpoch].startBlock;var futureRounds=[];for(var i=1;i<=FUTURE_ROUND_COUNT;i++){futureRounds.push(makeFutureRoundResponse(currentEpoch+i,currentRoundStartBlockNumber+(intervalBlocks+BLOCK_PADDING)*i));}return _objectSpread(_objectSpread({},state),{},{status:status,currentEpoch:currentEpoch,bufferBlocks:bufferBlocks,intervalBlocks:intervalBlocks,rewardRate:rewardRate,currentRoundStartBlockNumber:currentRoundStartBlockNumber,claimableStatuses:claimableStatuses,ledgers:ledgers,rounds:merge({},rounds,makeRoundData(futureRounds))});});// Get single round\nbuilder.addCase(fetchRound.fulfilled,function(state,action){state.rounds=merge({},state.rounds,_defineProperty({},action.payload.epoch.toString(),action.payload));});// Get multiple rounds\nbuilder.addCase(fetchRounds.fulfilled,function(state,action){state.rounds=merge({},state.rounds,action.payload);});// Show History\nbuilder.addCase(fetchHistory.pending,function(state){state.isFetchingHistory=true;});builder.addCase(fetchHistory.rejected,function(state){state.isFetchingHistory=false;state.isHistoryPaneOpen=true;});builder.addCase(fetchHistory.fulfilled,function(state,action){var _action$payload4=action.payload,account=_action$payload4.account,bets=_action$payload4.bets;state.isFetchingHistory=false;state.isHistoryPaneOpen=true;state.history[account]=bets;});}});// Actions\nvar _predictionsSlice$act=predictionsSlice.actions,setChartPaneState=_predictionsSlice$act.setChartPaneState,setCurrentEpoch=_predictionsSlice$act.setCurrentEpoch,setHistoryFilter=_predictionsSlice$act.setHistoryFilter,setHistoryPaneState=_predictionsSlice$act.setHistoryPaneState,setPredictionStatus=_predictionsSlice$act.setPredictionStatus,setLastOraclePrice=_predictionsSlice$act.setLastOraclePrice,markBetHistoryAsCollected=_predictionsSlice$act.markBetHistoryAsCollected;export{setChartPaneState,setCurrentEpoch,setHistoryFilter,setHistoryPaneState,setPredictionStatus,setLastOraclePrice,markBetHistoryAsCollected};export default predictionsSlice.reducer;","map":{"version":3,"sources":["/home/kodachi/Desktop/Frontend1/src/state/predictions/index.ts"],"names":["createAsyncThunk","createSlice","maxBy","merge","range","BIG_ZERO","HistoryFilter","PredictionStatus","getPredictionsContract","getBetHistory","transformBetResponse","makeFutureRoundResponse","makeRoundData","getRoundsData","getPredictionData","getLedgerData","makeLedgerData","serializePredictionsRoundsResponse","getClaimStatuses","PAST_ROUND_COUNT","FUTURE_ROUND_COUNT","BLOCK_PADDING","initialState","status","INITIAL","isLoading","isHistoryPaneOpen","isChartPaneOpen","isFetchingHistory","historyFilter","ALL","currentEpoch","currentRoundStartBlockNumber","intervalBlocks","bufferBlocks","minBetAmount","rewardRate","lastOraclePrice","toJSON","rounds","history","ledgers","claimableStatuses","initializePredictions","account","marketData","epochs","roundsResponse","initialRoundData","reduce","accum","roundResponse","reduxNodeRound","epoch","toString","initializedData","ledgerResponses","fetchRound","predictionContract","response","fetchRounds","round","fetchMarketData","fetchLedgerData","fetchClaimableStatuses","fetchHistory","claimed","user","toLowerCase","bets","map","predictionsSlice","name","reducers","setPredictionStatus","state","action","payload","setHistoryPaneState","setChartPaneState","setHistoryFilter","setCurrentEpoch","setLastOraclePrice","markBetHistoryAsCollected","betId","betIndex","findIndex","bet","id","extraReducers","builder","addCase","fulfilled","newestRound","Object","values","futureRound","startBlock","futureRounds","i","push","pending","rejected","actions","reducer"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\nimport { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport maxBy from 'lodash/maxBy'\nimport merge from 'lodash/merge'\nimport range from 'lodash/range'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport { Bet, LedgerData, HistoryFilter, PredictionsState, PredictionStatus, ReduxNodeRound } from 'state/types'\nimport { getPredictionsContract } from 'utils/contractHelpers'\nimport {\n  getBetHistory,\n  transformBetResponse,\n  makeFutureRoundResponse,\n  makeRoundData,\n  getRoundsData,\n  getPredictionData,\n  MarketData,\n  getLedgerData,\n  makeLedgerData,\n  serializePredictionsRoundsResponse,\n  getClaimStatuses,\n} from './helpers'\n\nconst PAST_ROUND_COUNT = 5\nconst FUTURE_ROUND_COUNT = 2\n\n// The estimated time it takes to broadcast\nexport const BLOCK_PADDING = 3\n\nconst initialState: PredictionsState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  currentRoundStartBlockNumber: 0,\n  intervalBlocks: 100,\n  bufferBlocks: 20,\n  minBetAmount: '1000000000000000',\n  rewardRate: 97,\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: {},\n  ledgers: {},\n  claimableStatuses: {},\n}\n\n// Thunks\n// V2 REFACTOR\ntype PredictionInitialization = Pick<\n  PredictionsState,\n  | 'status'\n  | 'currentEpoch'\n  | 'intervalBlocks'\n  | 'bufferBlocks'\n  | 'minBetAmount'\n  | 'rewardRate'\n  | 'rounds'\n  | 'ledgers'\n  | 'claimableStatuses'\n>\nexport const initializePredictions = createAsyncThunk<PredictionInitialization, string>(\n  'predictions/intialize',\n  async (account = null) => {\n    // Static values\n    const marketData = await getPredictionData()\n    const epochs = range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT)\n\n    // Round data\n    const roundsResponse = await getRoundsData(epochs)\n    const initialRoundData: { [key: string]: ReduxNodeRound } = roundsResponse.reduce((accum, roundResponse) => {\n      const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse)\n\n      return {\n        ...accum,\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\n      }\n    }, {})\n\n    const initializedData = {\n      ...marketData,\n      rounds: initialRoundData,\n      ledgers: {},\n      claimableStatuses: {},\n    }\n\n    if (!account) {\n      return initializedData\n    }\n\n    // Bet data\n    const ledgerResponses = await getLedgerData(account, epochs)\n\n    // Claim statuses\n    const claimableStatuses = await getClaimStatuses(account, epochs)\n\n    return merge({}, initializedData, {\n      ledgers: makeLedgerData(account, ledgerResponses, epochs),\n      claimableStatuses,\n    })\n  },\n)\n\nexport const fetchRound = createAsyncThunk<ReduxNodeRound, number>('predictions/fetchRound', async (epoch) => {\n  const predictionContract = getPredictionsContract()\n  const response = await predictionContract.rounds(epoch)\n  return serializePredictionsRoundsResponse(response)\n})\n\nexport const fetchRounds = createAsyncThunk<{ [key: string]: ReduxNodeRound }, number[]>(\n  'predictions/fetchRounds',\n  async (epochs) => {\n    const rounds = await getRoundsData(epochs)\n    return rounds.reduce((accum, round) => {\n      if (!round) {\n        return accum\n      }\n\n      const reduxNodeRound = serializePredictionsRoundsResponse(round)\n\n      return {\n        ...accum,\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\n      }\n    }, {})\n  },\n)\n\nexport const fetchMarketData = createAsyncThunk<MarketData>('predictions/fetchMarketData', async () => {\n  const marketData = await getPredictionData()\n  return marketData\n})\n\nexport const fetchLedgerData = createAsyncThunk<LedgerData, { account: string; epochs: number[] }>(\n  'predictions/fetchLedgerData',\n  async ({ account, epochs }) => {\n    const ledgers = await getLedgerData(account, epochs)\n    return makeLedgerData(account, ledgers, epochs)\n  },\n)\n\nexport const fetchClaimableStatuses = createAsyncThunk<\n  PredictionsState['claimableStatuses'],\n  { account: string; epochs: number[] }\n>('predictions/fetchClaimableStatuses', async ({ account, epochs }) => {\n  const ledgers = await getClaimStatuses(account, epochs)\n  return ledgers\n})\n// END V2 REFACTOR\n\nexport const fetchHistory = createAsyncThunk<{ account: string; bets: Bet[] }, { account: string; claimed?: boolean }>(\n  'predictions/fetchHistory',\n  async ({ account, claimed }) => {\n    const response = await getBetHistory({\n      user: account.toLowerCase(),\n      claimed,\n    })\n    const bets = response.map(transformBetResponse)\n\n    return { account, bets }\n  },\n)\n\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setPredictionStatus: (state, action: PayloadAction<PredictionStatus>) => {\n      state.status = action.payload\n    },\n    setHistoryPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isHistoryPaneOpen = action.payload\n      state.historyFilter = HistoryFilter.ALL\n    },\n    setChartPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isChartPaneOpen = action.payload\n    },\n    setHistoryFilter: (state, action: PayloadAction<HistoryFilter>) => {\n      state.historyFilter = action.payload\n    },\n    setCurrentEpoch: (state, action: PayloadAction<number>) => {\n      state.currentEpoch = action.payload\n    },\n    setLastOraclePrice: (state, action: PayloadAction<string>) => {\n      state.lastOraclePrice = action.payload\n    },\n    markBetHistoryAsCollected: (state, action: PayloadAction<{ account: string; betId: string }>) => {\n      const { account, betId } = action.payload\n\n      if (state.history[account]) {\n        const betIndex = state.history[account].findIndex((bet) => bet.id === betId)\n\n        if (betIndex >= 0) {\n          state.history[account][betIndex].claimed = true\n        }\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    // Claimable statuses\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload)\n    })\n\n    // Ledger (bet) records\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\n      state.ledgers = merge({}, state.ledgers, action.payload)\n    })\n\n    // Get static market data\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\n      const { status, currentEpoch, intervalBlocks, bufferBlocks, minBetAmount, rewardRate } = action.payload\n\n      // If the round has change add a new future round\n      if (state.currentEpoch !== currentEpoch) {\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch')\n        const futureRound = makeFutureRoundResponse(\n          newestRound.epoch + 1,\n          newestRound.startBlock + (state.intervalBlocks + BLOCK_PADDING),\n        )\n\n        state.rounds[futureRound.epoch] = futureRound\n        state.currentRoundStartBlockNumber = state.currentRoundStartBlockNumber + state.intervalBlocks + BLOCK_PADDING\n      }\n\n      state.status = status\n      state.currentEpoch = currentEpoch\n      state.intervalBlocks = intervalBlocks\n      state.bufferBlocks = bufferBlocks\n      state.minBetAmount = minBetAmount\n      state.rewardRate = rewardRate\n    })\n\n    // Initialize predictions\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\n      const { status, currentEpoch, bufferBlocks, intervalBlocks, rounds, claimableStatuses, rewardRate, ledgers } =\n        action.payload\n      const currentRoundStartBlockNumber = action.payload.rounds[currentEpoch].startBlock\n      const futureRounds: ReduxNodeRound[] = []\n\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\n        futureRounds.push(\n          makeFutureRoundResponse(\n            currentEpoch + i,\n            currentRoundStartBlockNumber + (intervalBlocks + BLOCK_PADDING) * i,\n          ),\n        )\n      }\n\n      return {\n        ...state,\n        status,\n        currentEpoch,\n        bufferBlocks,\n        intervalBlocks,\n        rewardRate,\n        currentRoundStartBlockNumber,\n        claimableStatuses,\n        ledgers,\n        rounds: merge({}, rounds, makeRoundData(futureRounds)),\n      }\n    })\n\n    // Get single round\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, {\n        [action.payload.epoch.toString()]: action.payload,\n      })\n    })\n\n    // Get multiple rounds\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, action.payload)\n    })\n\n    // Show History\n    builder.addCase(fetchHistory.pending, (state) => {\n      state.isFetchingHistory = true\n    })\n    builder.addCase(fetchHistory.rejected, (state) => {\n      state.isFetchingHistory = false\n      state.isHistoryPaneOpen = true\n    })\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const { account, bets } = action.payload\n\n      state.isFetchingHistory = false\n      state.isHistoryPaneOpen = true\n      state.history[account] = bets\n    })\n  },\n})\n\n// Actions\nexport const {\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  setPredictionStatus,\n  setLastOraclePrice,\n  markBetHistoryAsCollected,\n} = predictionsSlice.actions\n\nexport default predictionsSlice.reducer\n"]},"metadata":{},"sourceType":"module"}